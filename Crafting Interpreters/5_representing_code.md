# Representing Code

We are going to use a tree to represent the syntactic grammar of our code. In part 3, we will use byte code to do this, which isn’t as human friendly, but it is closer to the machine.

![Tree](http://craftinginterpreters.com/image/representing-code/tree-evaluate.png￼)

## Context-Free Grammars

For the Scanner, the “alphabet” was characters which were used to make tokens, or “strings”. For the Parser, the “alphabet” is tokens, which are used to make expressions, or “strings”. We are at a different level of granularity.

### Rules for grammars

In order to create valid strings, we need a finite set of rules. Strings are then generated by these grammar rules. These are called derivations (they are derived from the rules). Rules are called productions because they produce strings in the grammar.

Each production has a head and body - its name and something that describes what it generates (or a list of symbols). There are two types of symbols - terminals are letters from the grammar’s alphabet (in this case, tokens). They are called terminals in the sense of “end point”. You can just produce that one symbol. A nonterminal is a named reference to another rule in the grammar. This is what is used to compose strings. “Play that rule and insert whatever it produces here”.

Multiple rules can have the same name.

```
breakfast  → protein "with" breakfast "on the side" ;
breakfast  → protein ;
breakfast  → bread ;

protein    → crispiness "crispy" "bacon" ;
protein    → "sausage" ;
protein    → cooked "eggs" ;

crispiness → "really" ;
crispiness → "really" crispiness ;

cooked     → "scrambled" ;
cooked     → "poached" ;
cooked     → "fried" ;

bread      → "toast" ;
bread      → "biscuits" ;
bread      → "English muffin" ;
```

![Tree](http://craftinginterpreters.com/image/representing-code/breakfast.png)

### Enhancing our notation

Our notation works, but it’s tedious. Let’s sprinkle some syntactic sugar on top. 

`bread → "toast" | "biscuits" | "English muffin" ;`
`protein → ( "scrambled" | "poached" | "fried" ) "eggs" ;`
`crispiness → "really" "really"* ;`
`crispiness → "really"+ ;`
`breakfast → protein ( "with" breakfast "on the side" )? ;`

```
breakfast → protein ( "with" breakfast "on the side" )?
          | bread ;

protein   → "really"+ "crispy" "bacon"
          | "sausage"
          | ( "scrambled" | "poached" | "fried" ) "eggs" ;

bread     → "toast" | "biscuits" | "English muffin" ;
```

### A Grammar for Lox expressions 

Since the syntactic grammar is much larger than the lexical grammar, we will only focus on a handful of expressions for now

Literals, unary expressions, binary expressions, and parentheses for grouping. We’ll be able to work with:

`1 - (2 * 3) < 4 == false`

Here’s our new grammar for these expressions:

```
expression → literal
           | unary
           | binary
           | grouping ;

literal    → NUMBER | STRING | "true" | "false" | "nil" ;
grouping   → "(" expression ")" ;
unary      → ( "-" | "!" ) expression ;
binary     → expression operator expression ;
operator   → "==" | "!=" | "<" | "<=" | ">" | ">="
           | "+"  | "-"  | "*" | "/" ;
```

This is good enough for now, but too ambiguous for the parser later on.

## Implementing Syntax Trees

Since our expression grammar is recursive, our syntax will form a tree - “syntax tree”

Our scanner used a single Token class to represent all kinds of lexemes. To distinguish different types, 123 vs. “123”, we included TokenType.

To get the most out of Java’s type system, we’ll create a base class for expressions, then for each production under `expression`, we’ll create a subclass that has fields for the specific nonterminals it needs.

```
package com.craftinginterpreters.lox;

abstract class Expr { 
  static class Binary extends Expr {
    Binary(Expr left, Token operator, Expr right) {
      this.left = left;
      this.operator = operator;
      this.right = right;
    }

    final Expr left;
    final Token operator;
    final Expr right;
  }

  // Other expressions...
}
```

### Disoriented objects

These trees are not owned by the interpreter or the parser, so it doesn’t make sense to include methods from either one inside the `Expr` class. These classes exist to help the interpreter and parser to communicate, so no need for methods. (This is normal style in a functional language like Lisp, but weird in Java).

### Metaprogramming the trees

Even though Java can express function-less classes, it isn’t good at it. Also, there’s going to be 21 subclasses in the `Expr` class, so let’s automate some of this.

```
package com.craftinginterpreters.tool;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.List;

public class GenerateAst {
  public static void main(String[] args) throws IOException {
    if (args.length != 1) {
      System.err.println("Usage: generate_ast <output directory>");
      System.exit(64);
    }
    String outputDir = args[0];
  }
}
```
This will be in `.tool`, since it is a tool we use to create another java file filled with syntax tree classes. 

```
defineAst(outputDir, "Expr", Arrays.asList(
      "Binary   : Expr left, Token operator, Expr right",
      "Grouping : Expr expression",
      "Literal  : Object value",
      "Unary    : Token operator, Expr right"
    ));
```
Each field has a type and a name.
```
  private static void defineAst(
      String outputDir, String baseName, List<String> types)
      throws IOException {
    String path = outputDir + "/" + baseName + ".java";
    PrintWriter writer = new PrintWriter(path, "UTF-8");

    writer.println("package com.craftinginterpreters.lox;");
    writer.println();
    writer.println("import java.util.List;");
    writer.println();
    writer.println("abstract class " + baseName + " {");

    writer.println("}");
    writer.close();
  }
```

`defineAst()` will output the Expression class (`baseName`)

```
    // The AST classes.
    for (String type : types) {
      String className = type.split(":")[0].trim();
      String fields = type.split(":")[1].trim(); 
      defineType(writer, baseName, className, fields);
    }
```
How we define each subclass, which calls:

```
  private static void defineType(
      PrintWriter writer, String baseName,
      String className, String fieldList) {
    writer.println("  static class " + className + " extends " +
        baseName + " {");

    // Constructor.
    writer.println("    " + className + "(" + fieldList + ") {");

    // Store parameters in fields.
    String[] fields = fieldList.split(", ");
    for (String field : fields) {
      String name = field.split(" ")[1];
      writer.println("      this." + name + " = " + name + ";");
    }

    writer.println("    }");

    // Fields.
    writer.println();
    for (String field : fields) {
      writer.println("    final " + field + ";");
    }

    writer.println("  }");
  }
```
All this code will declare each field in the class body. It will define a constructor for the class with parameters for each field and initialize them in the body.

## Working with Trees

Since every expression will behave differently at runtime, the interpreter needs to be able to handle each expression type. A bunch of `if else` statements would be too slow, so we’ll create an `interpret()`method on the Expression class so the subclasses can interpret themselves.

### The Expression Problem

￼![OOP Table](http://craftinginterpreters.com/image/representing-code/table.png)

OOP languages like Java assumes all of the code in a row hangs together, so it makes it easy to define a method inside a class. So it becomes easy to “add another row”

￼![Class table](http://craftinginterpreters.com/image/representing-code/rows.png)

But adding a new operation (column) means editing all of these rows.

Functional programming languages flip this around. Functions are easy to add, but types are difficult. - 

￼![Function Table](http://craftinginterpreters.com/image/representing-code/columns.png)

This is called the “expression problem” - it is difficult to add rows and columns at the same time.

### The Visitor pattern

This design pattern is about trying to simulate functional style in an OOP language. We will be able to define a new behavior for a set of types, without touching the types themselves.

```
  abstract class Pastry {
        abstract void accept(PastryVisitor visitor);
  }

  class Beignet extends Pastry {
    @Override
    void accept(PastryVisitor visitor) {
      visitor.visitBeignet(this);
  }

  class Cruller extends Pastry {
    @Override
    void accept(PastryVisitor visitor) {
      visitor.visitCruller(this);
  }
```
```
  interface PastryVisitor {
    void visitBeignet(Beignet beignet); 
    void visitCruller(Cruller cruller);
  }
```

![Food Example](http://craftinginterpreters.com/image/representing-code/visitor.png)

We can add one `accept()` method to each class, but we can pass any visitor to it in the future without touching the pastry class again.

### Visitors for expressions

We shouldn’t assume all visitors will have the same return type, so we’ll let each implementation determine this.

`defineVisitor(writer, baseName, types);`
```
  private static void defineVisitor(
      PrintWriter writer, String baseName, List<String> types) {
    writer.println("  interface Visitor<R> {");

    for (String type : types) {
      String typeName = type.split(":")[0].trim();
      writer.println("    R visit" + typeName + baseName + "(" +
          typeName + " " + baseName.toLowerCase() + ");");
    }

    writer.println("  }");
  }
```

This loops through all of the subclasses and declares a visit method for each one. This will automatically include return types later on.

```
    // The base accept() method.
    writer.println();
    writer.println("  abstract <R> R accept(Visitor<R> visitor);");
```

```
    // Visitor pattern.
    writer.println();
    writer.println("    @Override");
    writer.println("    <R> R accept(Visitor<R> visitor) {");
    writer.println("      return visitor.visit" +
        className + baseName + "(this);");
    writer.println("    }");
```

Each subclass implements the `abstract()` method and calls the right visit method for its own type.

## A (Not Very) Pretty Printer

When debugging our parser and interpreter, it is useful to look at a parsed syntax tree and make sure it has the structure we expect. Using the debugger would be a chore, so we’ll convert the tree to a string (called a “pretty printer”). 

But we won’t use that here. We will instead print out Lisp syntax, to be better able to see the hierarchy of our syntax. 

￼![Code Structure example](http://craftinginterpreters.com/image/representing-code/expression.png)

This will produce `(* (- 123) (group 45.67))`

Let’s define a new class.

```
package com.craftinginterpreters.lox;

// Creates an unambiguous, if ugly, string representation of AST nodes.
class AstPrinter implements Expr.Visitor<String> {
  String print(Expr expr) {
    return expr.accept(this);
  }

  @Override
  public String visitBinaryExpr(Expr.Binary expr) {
    return parenthesize(expr.operator.lexeme, expr.left, expr.right);
  }

  @Override
  public String visitGroupingExpr(Expr.Grouping expr) {
    return parenthesize("group", expr.expression);
  }

  @Override
  public String visitLiteralExpr(Expr.Literal expr) {
    if (expr.value == null) return "nil";
    return expr.value.toString();
  }

  @Override
  public String visitUnaryExpr(Expr.Unary expr) {
    return parenthesize(expr.operator.lexeme, expr.right);
  }

  private String parenthesize(String name, Expr... exprs) {
    StringBuilder builder = new StringBuilder();

    builder.append("(").append(name);
    for (Expr expr : exprs) {
      builder.append(" ");
      builder.append(expr.accept(this));
    }
    builder.append(")");

    return builder.toString();
  }
}
``` 