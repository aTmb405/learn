# Representing Code

We are going to use a tree to represent the syntactic grammar of our code. In part 3, we will use byte code to do this, which isn’t as human friendly, but it is closer to the machine.

![Tree](http://craftinginterpreters.com/image/representing-code/tree-evaluate.png￼)

## Context-Free Grammars

For the Scanner, the “alphabet” was characters which were used to make tokens, or “strings”. For the Parser, the “alphabet” is tokens, which are used to make expressions, or “strings”. We are at a different level of granularity.

### Rules for grammars

In order to create valid strings, we need a finite set of rules. Strings are then generated by these grammar rules. These are called derivations (they are derived from the rules). Rules are called productions because they produce strings in the grammar.

Each production has a head and body - its name and something that describes what it generates (or a list of symbols). There are two types of symbols - terminals are letters from the grammar’s alphabet (in this case, tokens). They are called terminals in the sense of “end point”. You can just produce that one symbol. A nonterminal is a named reference to another rule in the grammar. This is what is used to compose strings. “Play that rule and insert whatever it produces here”.

Multiple rules can have the same name.

```
breakfast  → protein "with" breakfast "on the side" ;
breakfast  → protein ;
breakfast  → bread ;

protein    → crispiness "crispy" "bacon" ;
protein    → "sausage" ;
protein    → cooked "eggs" ;

crispiness → "really" ;
crispiness → "really" crispiness ;

cooked     → "scrambled" ;
cooked     → "poached" ;
cooked     → "fried" ;

bread      → "toast" ;
bread      → "biscuits" ;
bread      → "English muffin" ;
```

![Tree](http://craftinginterpreters.com/image/representing-code/breakfast.png)

### Enhancing our notation

Our notation works, but it’s tedious. Let’s sprinkle some syntactic sugar on top. 

`bread → "toast" | "biscuits" | "English muffin" ;`
`protein → ( "scrambled" | "poached" | "fried" ) "eggs" ;`
`crispiness → "really" "really"* ;`
`crispiness → "really"+ ;`
`breakfast → protein ( "with" breakfast "on the side" )? ;`

```
breakfast → protein ( "with" breakfast "on the side" )?
          | bread ;

protein   → "really"+ "crispy" "bacon"
          | "sausage"
          | ( "scrambled" | "poached" | "fried" ) "eggs" ;

bread     → "toast" | "biscuits" | "English muffin" ;
```

### A Grammar for Lox expressions 

Since the syntactic grammar is much larger than the lexical grammar, we will only focus on a handful of expressions for now

Literals, unary expressions, binary expressions, and parentheses for grouping. We’ll be able to work with:

`1 - (2 * 3) < 4 == false`

Here’s our new grammar for these expressions:

```
expression → literal
           | unary
           | binary
           | grouping ;

literal    → NUMBER | STRING | "true" | "false" | "nil" ;
grouping   → "(" expression ")" ;
unary      → ( "-" | "!" ) expression ;
binary     → expression operator expression ;
operator   → "==" | "!=" | "<" | "<=" | ">" | ">="
           | "+"  | "-"  | "*" | "/" ;
```

This is good enough for now, but too ambiguous for the parser later on.

## Implementing Syntax Trees

Since our expression grammar is recursive, our syntax will form a tree - “syntax tree”

Our scanner used a single Token class to represent all kinds of lexemes. To distinguish different types, 123 vs. “123”, we included TokenType.

To get the most out of Java’s type system, we’ll create a base class for expressions, then for each production under `expression`, we’ll create a subclass that has fields for the specific nonterminals it needs.

```
package com.craftinginterpreters.lox;

abstract class Expr { 
  static class Binary extends Expr {
    Binary(Expr left, Token operator, Expr right) {
      this.left = left;
      this.operator = operator;
      this.right = right;
    }

    final Expr left;
    final Token operator;
    final Expr right;
  }

  // Other expressions...
}
```

### Disoriented objects

These trees are not owned by the interpreter or the parser, so it doesn’t make sense to include methods from either one inside the `Expr` class. These classes exist to help the interpreter and parser to communicate, so no need for methods. (This is normal style in a functional language like Lisp, but weird in Java).

### Metaprogramming the trees

Even though Java can express function-less classes, it isn’t good at it. Also, there’s going to be 21 subclasses in the `Expr` class, so let’s automate some of this.

```
package com.craftinginterpreters.tool;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.List;

public class GenerateAst {
  public static void main(String[] args) throws IOException {
    if (args.length != 1) {
      System.err.println("Usage: generate_ast <output directory>");
      System.exit(64);
    }
    String outputDir = args[0];
  }
}
```
This will be in `.tool`, since it is a tool we use to create another java file filled with syntax tree classes. 

```
defineAst(outputDir, "Expr", Arrays.asList(
      "Binary   : Expr left, Token operator, Expr right",
      "Grouping : Expr expression",
      "Literal  : Object value",
      "Unary    : Token operator, Expr right"
    ));
```
Each field has a type and a name.
```
  private static void defineAst(
      String outputDir, String baseName, List<String> types)
      throws IOException {
    String path = outputDir + "/" + baseName + ".java";
    PrintWriter writer = new PrintWriter(path, "UTF-8");

    writer.println("package com.craftinginterpreters.lox;");
    writer.println();
    writer.println("import java.util.List;");
    writer.println();
    writer.println("abstract class " + baseName + " {");

    writer.println("}");
    writer.close();
  }
```